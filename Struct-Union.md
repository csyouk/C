# Struct, Union, Enum
- induced type

## Structure
- 구조체는 서로 다른 타입들의 집합이다.
- 구조체를 template이라고도 한다.
- 구조체를 구성하는 타입들을 멤버라고 한다.
  - 구조체의 멤버에 접근할 때는 **.** 단항 연산자를 사용해서 접근한다.
- 구조체 선언을 할 때, 멤버의 타입을 지정하는 것은 가능하나, 저장공간을 지정하는 것을 불가하다.

- 구조체를 다음과 같은 방식으로 초기화한다.

```cpp

// 구조체 요소들의 각 명칭을 알아보자.
// struct를 '예약어'라고 한다.
// User를 'tag'라고 한다.
// name, age, phoneNumber 등을 '멤버'라고 한다.
// cs, yj, peter 등은 User타입을 통해 만들어진 '변수'이다.

struct User {
  char name[6];
  short age;
  long long phoneNumber;
} cs, yj, peter;

// 위 선언과 아래 선언은 동일하다.
typedef struct {
  char Name[10];
  int Age;
  double Height;
} FriendType;

```

- *배열명* 은 첫 요소의 주소였다. *구조체* 이름은 주소가 아니다.
- **배열을 함수에 넘기면 내용이 복사되지 않고 주소가 전달된다. (call by address)**
- **구조체를 함수에 넘기면 내용이 통째로 복사되어 전달된다. (call by value)**

- 구조체의 구성요소는 최대한 32bit의 배수로 맞춰주는 것이 좋다. 최대한 padding bits들이 발생하지 않는 것이 좋다.
- padding bits를 아낄수록 좋다.

- 이처럼 구조체 멤버들의 타입은 제각각 이기 때문에, 해당 멤버로 접근하기 위해서는
구조체의 시작번지로부터 멤버까지의 offset을 더해서 멤버를 읽어야 한다.
- 컴파일러는 구조체가 선언될 때 각 멤버의 오프셋과 타입을 기억해둔다. 멤버를 참조하는 문장을 만나면 구조체의
시작 번지에서 오프셋을 더한만큼 이동한 후 이 위치에서 멤버의 타입 길이만큼 값을 읽도록 코드를 생성할 것이다.
이러한 동작을 하는 연산자가 **.** 연산자 이다.


```cpp
// 아래와 같이 선언을 하게 되면, age는 4바이트를 차지하고 있지만,
// sex는 1바이트를 선언하게 된다. 3바이트 만큼은 여분에 해당한다.
// 구조체가 전역에 선언되어 있다면, 패딩 비트들은 0으로 채워진다.
// 구조체가 지역에 선언되어 있다면, 쓰레기 값이 들어가 있게 된다.(지역일 경우)
struct User{
  int age;
  char sex;
}

```

## Union
- 같은 메모리를 여러 멤버가 공유하는 개념.
- 핵심 : **같은 값을 다른 관점을 해석해서 사용한다.**
- 다음 예제로 이해해본다.
```cpp

union uni{
  int a;
  unsigned char b;
} x = {0x12345678};

/*
  x 값은 리틀엔디언 방식으로 0x12345678이 들어가있다.
  a는 4바이트 정수에 해당하므로 모든 값을 다 읽는다. 즉, 0x12345678
  b는 1바이트 문자이므로 공유하는 메모리 중 하단의 1바이트를 읽는다. 즉, 0x78   
*/

```
- 공용체는 ip주소를 나타내는 경우에 아주 유용하다.
```cpp

	union IP
	{
		unsigned long addr;
		unsigned char sub[4];
	} ip = {0xff3953d2};

  // 255.57.83.210
	printf("ip addr : %d.%d.%d.%d", ip.sub[3], ip.sub[2], ip.sub[1], ip.sub[0]);

```

- 구조체와 공용체를 통해 변수를 선언하는 방법은 다음과 같다.
- 변수를 선언할 때, 왜 예약어를 앞에 붙일까? 에 대해서 컴파일러 입장에서 생각해보자.
- 다음과 같이 구조체가 선언되어 있다고 해보자.
```cpp
  struct st {
    int a;
    char b;
  } ;
```
- ```st x;``` 와 같이 변수를 선언한다고 하면, 이 구문을 해석하는 컴파일러 입장에서는
이 st라는 타입이 struct인지, union인지, enum인지 알수가 없다. 따라서 타입 앞에 초기화에
사용했던 예약어를 사용해주는 것이 좋다.
- 다음과 같이 하는 것이 옳다.
- ```struct st x;```

### 악마는 디테일에 있다.(구조체 선언시 tag를 붙이고 안붙이고.)
- 다음과 같은 두가지 구조체가 있을 때, 차이는 무엇일까?
```cpp
// 1
struct st{
  int a;
  char b;
} x,y,z;

// 2
struct {
  int a;
  char b;
} k,l,m;
```

- 1번 케이스는 **struct st** 라는 타입을 가지고 추가로 변수 생성이 가능하다.
- 2번 케이스는 타입을 알수가 없다. **tag** 가 없으므로 재활용이 불가하다.
이런 케이스는 k,l,m이라는 변수만 쓰겠다는 의도이다.

### 구조체와 멤버의 타입 추론, 초기화 시점과 멤버 값 업데이트
```cpp
struct st {
  int a;
  char b;
};

struct st x = {100, 'A'}; // 가능
struct st y;
y = {100, 'A'}; // 불가능
```
- x의 타입은 ```struct st```타입이다.
- x.a의 타입(x의 멤버 a)은 멤버의 타입인 **int** 형이다.
- 구조체 선언시에 값을 할당하는 것은 가능하다. 그러나, 구조체 선언 후, 구조체 변수에 초기화 시키는 것을 가능하다.


## Enumeration
- 말그대로 "열거"하는 타입이다.
- enum 타입을 통해서 magic number들을 없앨 수 있다.
- 코드의 가독성을 높일 수 있다.
- 각 요소별로 값을 지정하는 것 또한 가능하다.

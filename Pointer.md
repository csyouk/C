# Pointer

- 오직 포인터 변수만이 **void** 를 지시할 수 있다.
- ```void *a;``` 구문이 지시하는 바는, 포인터 변수 a가 지시하는 변수의 타입을 모른다는 뜻이다.
- 포인터 변수 그 자체는 통상적으로 주소를 담기 때문에, 4B의 값이 쓰여진다.(32비트 기준.) 4B의 메모리 공간에는 지시하는 변수의 메모리 주소값이 담긴다.
- **포인터 변수의 선언식에서 중요한 것은,** 포인터 변수 자체에 담긴 값이 아니라, **포인터 변수가 지시하는 변수의 타입이다.**
- \*, [] 연산자는 피연산자로 주소의 값을 담고 있는 변수를 취한다.

```cpp
char *p;
int *q;
short *r;
struct *s;

위의 선언식에서 중요한 지점은 포인터 변수 p,q,r,s가 가르키는 변수가
각각, char, int, short, struct 라는 타입을 가졌다는 것이다.

그렇다면, 각 포인터 변수의 데이터 타입을 무엇인가?
p : char (*) type
q : int (*) type
r : short (*) type
s : struct (*) type

```

## Pointer with single variable.

- 포인터 변수의 사전적인 정의는  다음과 같다.

  ***다른 변수의 메모리 공간주소를 가리키는 변수***

- 먼저 그림을 첨부한다. 이 예시를 토대로, 중요한 성질들을 도출해보자.
![Pointer](https://upload.wikimedia.org/wikipedia/ko/2/2f/Exam_int_point.png)

```cpp

int a[10];

int *pa = &a;

```
- a배열은 주소값 0x0040DF04부터 시작한다.
- &연산자는, 주소값을 반환한다.  
- int 포인터 변수 pa는 0x0040DF00에 위치한다. 그리고 그 메모리주소에는 0x00FD04라는 값을 가지고 있다.
- a라는 변수를 통해서 할 수 있는 작업은, 요소 참조 연산자를 통해서 해당 주소에 담긴 값을 직접적으로 가져오거나(read), 아니면 메모리 주소에 값을 쓸수(write)있다.
- 그렇다면 pa라는 포인터 변수를 통해서 할 수 있는 작업은 무엇인가? 이를 이해하기 위해서는 먼저 pa라는 포인터 변수와 결합되서 쓰이는 연산자는 어떠한 것들이 있는지, 또 그런 연산자와 결합된 결과값들이 어떠한 의미를 띄는지 알아야 한다.
- **변수 선언식에서 쓰인 \*의 역할은 해당 변수가 포인터 임을 알리는 기호(symbol)이다.** 즉, ``` int *pa = &a;``` 에서의 \*는 pa라는 변수가 포인터임을 알리는 **수정자(modifier)** 이다. pa라는 변수의 타입을 *수정* 한다는 뜻이다.
- 변수 선언식이 아닌 대입문에서 쓰인 \*는 indirection operator(dereference operator; 간접연산자, 역참조 연산자, 내용참조 연산자)라고 한다.
- ``` *pa = 3;```, ``` a[0] = 3;``` 두 식의 결과는 같지만, 행위는 다르다.
- 전자는 간접참조를 통해서 ```int *```타입을 가지고 있는 포인터 pa의 값을 읽어와서, 해당 값에 대응되는 메모리의 위치로 이동한 다음, 그 위치에 pa가 지시하는 변수의 타입(int)의 크기 만큼 값을 write한다.
- 반면, 후자는 요소참조 연산자(subscript operator)```[]```를 통해서 a배열의 0번째 위치에 정수 값을 write한다.

----------------
- 또 하나 포인터의 중요한 성질은, 포인터는 해당 변수가 지시하는 변수의 타입만큼의 frame을 가진다는 점이다.
- 예를 들어보면 다음과 같다.

```cpp
int a = 100;
int *p;
p = &a;

p 의 주소값이 0x1000 이라고 할때.
p + 1 의 주소값은 ? ==> 0x1004
p - 1 의 주소값은 ? ==> 0x0ffc

주소값이 0x4씩 뛰는 이유는, p가 지시하는 변수의 데이터 타입의 폭이 4B이기 때문이다.
```

------------------

## Pointer with Array(homogeneous, primitive).

- 배열명은 배열의 첫 요소의 주소이다.
- ```int a[3] = {1,2,3}; ```와 같은 선언식이 주어졌을 떄, 다음의 3가지 표현은 모두 같은 값을 가진다.(주소값이다.)
  - a
  - &a
  - &a[0]

- 그렇다면, 다른점은 무엇일까? 그에 대한 대답은 바로, '데이터 타입이 다르다는 것이다.'
  - a의 경우, ```int *``` 타입을 가진다.
  - &a의 경우 ```int (*)[3]``` 타입을 가진다.
  - &a[0]의 경우 ```int *``` 타입을 가진다.

- 다음의 예제를 살펴보자.

```cpp

  int a[3] = {3,4,5};
  int *p = &a;

  값을 표현하는 방법들  | 메모리 값 | 메모리 주소를 표현하는 방법들.
  *(a+0) = a[0]    |  3      |  &a    = &a[0] + 0 = a
  *(a+1) = a[1]    |  4      |  &a[1] = &a[0] + 1 = a + 1
  *(a+2) = a[2]    |  5      |  &a[2] = &a[0] + 2 = a + 2

  포인터 변수 p를 활용하면 더욱 더 다채로운 표현이 가능하다.
  값을 표현하는 방법들                       | 메모리 값 | 메모리 주소를 표현하는 방법들.
  *(p+0) = p[0] = *(a+0) = a[0]         |  3      |  &a    = &a[0] + 0 = a     = p
  *(p+1) = p[1] = *(a+1) = a[1]         |  4      |  &a[1] = &a[0] + 1 = a + 1 = p + 1
  *(p+2) = p[2] = *(a+2) = a[2]         |  5      |  &a[2] = &a[0] + 2 = a + 2 = p + 2

  *(p+n) = p[n] = *(a+n) = a[n]         | a 배열 n번째값 | &a[n] = &a[0] + n = a + n = p + n
  ==> 포인터 변수를 활용해서 p[3]와 같은 표현이 가능했던 이유는, []연산자가 피연산자로 주소값을 취하기 때문이다.
  ==> p[3]이 뜻하는 바는, p가 지시하는 데이터 타입에서
      3번째 점프한 만큼에 위치한 데이터를 데이터 타입만큼 긁어서 값을 보여준다는 뜻이다.

  !important
  *p[0] 이라는 표현을 가능할까? 결론부터 말하자면, 불가능 하다. 왜냐하면 l-value에러이기 때문이다.
  연산자 우선순위에 의해서 p[0]의 값이 계산되어서 상수값(주소값)이 나온다.
  주소값에 * operator를 통해서 값을 꺼내려고 시도했기 때문에, l-value에러가 나오게 된다.
```



## Pointer with character, character array.
- 문자열은 실제로는 문자들의 집합이다. 좀 더 전산학적으로 표현해보자면, char [] 타입에 들어간 문자들이다.
- ```char *p = "Hello";``` 와 같이 선언된 구문은, 실제로는 컴파일 시기에, " " symbol로 감싸여진 문자들의 크기를 미리 계산해서 text segment에 저장해 놓고, 해당 문자열이 시작하는 주소를 알려준다.
- 문자의 경우, 주소를 알게되면, 시작 주소지점부터 해서 '\0'를 만날때까지 계속 메모리를 읽으며 문자를 출력한다.

- 다음은 %s output format directive에 대응되는 기능을 작성한 코드이다.

```cpp

void percent_s(char *p)
{
	while (*p) printf("%c", *p++);
}

percent_s("hello");
```

- 다음 2개의 코드는 어떤 차이점이 있을까?
```cpp
void main(void){
  char a[6] = "Hello";   // 1
  char *p = "Hello";     // 2
}
```
- 1번 선언식 같은 경우, a라는 배열이 main함수의 스택 내부에 쌓여서 6바이트 만큼의 공간을 차지한다.
- 2번 선언식 같은 경우, 컴파일 시점에 "Hello"라는 문자열의 사이즈와 크기를 계산해어 Read Only 행위만 가능한
Text segment영역으로(Data segment에 속함) 들어가게 된다. 그리고, 그 결과물로, 문자열의 시작주소만 반환한다. 개발자는 문자열이 가진
규칙을 활용해서(\0을 만날때까지 읽는다.) 문자열을 읽을 수 있게 된다.
- 2번 선언식 같이 문자열을 선언해서 주소값을 받은 경우, 해당 문자열의 문자요소의 값을 업데이트 할 수 없다.
  즉, p[0] = 'N'; 과 같은 행위가 불가하다.


## Double Pointer
- Modifer들이 연속으로 붙었을 때, 이들의 우선순위는 어떠한가?
- 예시를 들어보자.


```cpp
  int a = 10;     // 1
  int *p = &a;    // 2
  int **q = &p;   // 3
```
- 타입을 판별해 보도록 하자.
- 먼저 3을 해석해보자.
  - int \*  \*   q;
  - (3) (2) (1)
  - q로부터 가까운 연산자들을 먼저 처리한다. 즉 (1) -> (2) -> (3) 의 순으로 연산자들을 처리한다.
  - q의 데이터 타입은 (3)의 식에서 q를 제외한 나머지 만큼을 가리킨다. 즉, int ** 이다.
  - q라는 데이터는 int * 라는 타입을 가지고 있는 데이터를 지시하고, 그 자체도 포인터(*) 이다.

  - *q의 데이터 타입은 (3)의 식에서 *q를 제외한 나머지 만큼을 가리킨다. 즉, int * 이다.
  - *q라는 데이터는 int라는 타입을 가지고 있는 데이터를 지시하고, 그 자체도 포인터(*) 이다.





## Array of T pointers VS A pointer to an array of T
- T는 타입을 의미한다.
- Array of T pointers는 T라는 데이터 타입을 지시하는 포인터들이 모여있는 배열을 뜻한다.
- 배열 포인터 라고 한다.
- ```int *a[4];```
- a는 int * [4] 라는 데이터 타입을 가졌고, a는 배열이므로, 원소로 int * 라는 데이터 타입을 가지고 있다.


- A pointer to an array of T
- T라는 데이터타입을 가지고 있는 배열을 지시하는 포인터라는 뜻이다.
- 포인터 배열 이라고 한다.
- ```int (*a)[4];```
- a는 int (\*)[4] 라는 데이터 타입을 가지고 있는 변수이다. 통상적으로, int[4] (\*)라고 더 많이 쓴다.
  즉, a는 포인터 변수 이므로, 이 a가 지시하는 변수의 타입은 int[4] 이다.






## Pointer with heap segment allocation.
- Heap영역에 메모리의 영역을 할당하는 작업은 프로그래머가 직접적으로 할 수 없는 일이다.
- 이 일은 전적으로 OS가 권한을 가지고 있다.
- 이러한 힙 영역에 메모리를 할당하는데 쓰이는 함수는 3가지가 있다.
  - void * malloc(size_t size);
  - void * calloc(size_t num, size_t size);
  - void * realloc(void * block, size_t size);
  - 위 3가지 함수는 힙영역에 정해진 크기만큼의 메모리를 선점한 후, 해당 블록의 시작 주소를 반환한다.
  - 이 때, 반환 타입으로 ** void * ** 이 나오게 되는데, 이 말의 뜻은, 주소의 값이 반환값으로 나와서, 포인터 형의 변수에 담아야 하지만, 해당 포인터가 지시하는 데이터의 타입은 정해져 있지 않다는 뜻이다. 따라서, 변수 포인터에 담을때, 반드시 형을 지정해주도록 한다.
  - 예를 들면 이렇게.. ```int *p = malloc(40);```
  - 힙 영역이 모자라서 메모리 블록을 가질수 없을때 0x0값이 return으로 나오기도 한다. 이말은, 메모리 공간을 확보하지 못했다는 뜻이다. 이러한 예외 케이스가 생길 수 있으므로, 이러한 critical case를 방지하기 위해서, 다음과 같은 코드를 기계적으로 같이 붙여줘야 한다.

```cpp
  int *p = malloc(10 * sizeof(int));
  if(p == NULL) return;  // NULL은 매크로 상수이다. 0x0값이다.
```
- 위와 같이 에러케이스를 일찍 제거해주어 시스템의 안정서을 높여야 한다.

-----------------------
- 위의 3가지 함수를 통해서 메모리 블락을 선점하고 나서 메모리를 사용후에는 **반드시** 메모리 해제를 시켜줘야하는데, 이때쓰는 함수가 바로 **free** 함수이다.
- 함수의 인자로 포인터 변수를 넘겨줘야 한다. 


| malloc  |        
| calloc  | <====> | free |
| realloc |

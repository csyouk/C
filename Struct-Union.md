# Struct, Union, Enum
- 구조체, 공용체는 사용자(개발자)가 원하는 대로 템플릿을 만들어서 사용하므로 유도형(induced type)
변수라고 한다.
- **.** 연산자를 **멤버 참조 연산자**, **필드 참조 연산자** 라고 한다.

```cpp

  struct st {
    int a;
    char b;
  };

  struct st x;

  // x.a 에서 . 연산자의 대상. 즉 피연산자는 x 이다.
  // x.a 는 변수의 이름과 같다. 구조체의 멤버의 타입을 따른다.
  x.a = 100;

  // struct st 타입의 변수 x를 선언한 이후, 변수에 상수 식을 통해서 값을 대입하는 것을 불가능하다.
  x = {100, 'A'};

  // struct st2 타입의 변수 x를 상수식을 통해 초기화하는 것은, 선언시에만 가능하다.
  struct st2{
    int a;
    char b;
  } xx = {100, 'A'};

  struct st2 yy = {200, 'B'};

```

------------------------------------
## Structure (Struct)
- 구조체는 서로 다른 타입들의 집합이다.
- 구조체를 template이라고도 한다.
- 구조체를 구성하는 타입들을 멤버라고 한다.
  - 구조체의 멤버에 접근할 때는 **.** 단항 연산자를 사용해서 접근한다.
- 구조체 선언을 할 때, 멤버의 타입을 지정하는 것은 가능하나, 저장공간을 지정하는 것을 불가하다.

- 구조체를 다음과 같은 방식으로 초기화한다.

```cpp

// 구조체 요소들의 각 명칭을 알아보자.
// struct를 '예약어'라고 한다.
// User를 'tag'라고 한다.
// name, age, phoneNumber 등을 '멤버'라고 한다.
// cs, yj, peter 등은 User타입을 통해 만들어진 '변수'이다.


// 1
struct User {
  char name[6];
  short age;
  long long phoneNumber;
} cs, yj, peter;

// 2
typedef struct {
  char name[6];
  short age;
  long long phoneNumber;
} User;

// 3
struct {
  int a;
  char b;
} x, y, z = {203,'B'};

//==============================================================
// 1번과 2번 구조체 정의는 유사하지만, 변수 선언시에 차이점이 있다.
// 1번
  struct User cs; // 변수 cs는 struct User 타입이다.
// 2번  
  User cs;        // 변수 cs는 User 타입이다.
// 3반
  x = z;// 변수 x는 struct 타입이다.

//==============================================================
/*
  1, 2, 3번 구조체 선언은 유사한듯 서로 다르다.
  1번은 구조체의 태그가 존재한다.
  2번은 구조체의 태그가 존재하고 구조체 자체를 하나의 새로운 형으로 선언을 했다.
  3번은 구조체의 태그가 없다.

  1, 2번은 변수 선언이 구조체 선언 외부에서 가능하다.
  반면 3번은 변수 선언이 구조체 선언부에서만 가능하다.
  즉, 3번은 구조체를 재활용하지 않겠다는 의미이다.
  1, 2번은 구조체의 태그가 있으므로, 구조체 태그를 사용해서 새로운 변수 선언이 가능하다.


*/
```

- *배열명* 은 첫 요소의 주소였다. *구조체* 이름은 주소가 아니다.
- **배열을 함수에 넘기면 내용이 복사되지 않고 주소가 전달된다. (call by address)**
- **구조체를 함수에 넘기면 내용이 통째로 복사되어 전달된다. (call by value)**

- 구조체의 구성요소는 최대한 32bit의 배수로 맞춰주는 것이 좋다. 최대한 padding bits들이 발생하지 않는 것이 좋다.
- padding bits를 아낄수록 좋다.

- 이처럼 구조체 멤버들의 타입은 제각각 이기 때문에, 해당 멤버로 접근하기 위해서는
구조체의 시작번지로부터 멤버까지의 offset을 더해서 멤버를 읽어야 한다.
- 컴파일러는 구조체가 선언될 때 각 멤버의 오프셋과 타입을 기억해둔다. 멤버를 참조하는 문장을 만나면 구조체의
시작 번지에서 오프셋을 더한만큼 이동한 후 이 위치에서 멤버의 타입 길이만큼 값을 읽도록 코드를 생성할 것이다.
이러한 동작을 하는 연산자가 **.** 연산자 이다.

- **offset** 이란?
  - 일반적으로 동일 오브젝트 안에서 오브젝트 처음부터 주어진 요소나 지점까지의 변위차를 나타내는 정수형.
  - 이를테면, 문자 A의 배열이 abcdef를 포함한다면 'c' 문자는 A 시작점에서 2의 오프셋을 지닌다고 할 수 있다.
  - 어셈블리어와 같은 저급 프로그래밍 언어에서 오프셋은 상대 주소(relative address)로 부른다.

```cpp
// 아래와 같이 선언을 하게 되면, age는 4바이트를 차지하고 있지만,
// sex는 1바이트를 선언하게 된다. 3바이트 만큼은 여분에 해당한다.
// 구조체가 전역에 선언되어 있다면, 패딩 비트들은 0으로 채워진다.
// 구조체가 지역에 선언되어 있다면, 쓰레기 값이 들어가 있게 된다.(지역일 경우)
struct User{
  int age;
  char sex;
}

```

## Union

- 핵심 : **같은 값을 다른 멤버로 해석해서 사용한다.**
- 공용체는 같은 메모리를 여러 멤버가 공유한다.
- 구조체가 각 멤버가 서로 다른 메모리 영역을 차지하며 값을 가지고 있다면,
공용체는 공용체를 구성하는 각 멤버가 같은 메모리 영역에 대해서 각 멤버의 할당 바이트 만큼의 영역을 다르게 보고 해석한다.
- 다음 예제로 이해해본다.

```cpp

union uni{
  int a;
  unsigned char b;
} x = {0x12345678};

/*
  x 값은 리틀엔디언 방식으로 0x12345678이 들어가있다.
  a는 4바이트 정수에 해당하므로 모든 값을 다 읽는다. 즉, 0x12345678
  b는 1바이트 문자이므로 공유하는 메모리 중 하단의 1바이트를 읽는다. 즉, 0x78   
*/

```
- 공용체는 ip주소를 나타내는 경우에 아주 유용하다.
```cpp

	union IP
	{
		unsigned long addr;
		unsigned char sub[4];
	} ip = {0xff3953d2};

  // 255.57.83.210
	printf("ip addr : %d.%d.%d.%d", ip.sub[3], ip.sub[2], ip.sub[1], ip.sub[0]);

```

- 구조체와 공용체를 통해 변수를 선언하는 방법은 다음과 같다.
- 변수를 선언할 때, 왜 예약어를 앞에 붙일까? 에 대해서 컴파일러 입장에서 생각해보자.
- 다음과 같이 구조체가 선언되어 있다고 해보자.
```cpp
  struct st {
    int a;
    char b;
  } ;
```
- ```st x;``` 와 같이 변수를 선언한다고 하면, 이 구문을 해석하는 컴파일러 입장에서는
이 st라는 타입이 struct인지, union인지, enum인지 알수가 없다. 따라서 타입 앞에 초기화에
사용했던 예약어를 사용해주는 것이 좋다.
- 다음과 같이 하는 것이 옳다.
- ```struct st x;```

### 악마는 디테일에 있다.(구조체 선언시 tag를 붙이고 안붙이고.)
- 다음과 같은 두가지 구조체가 있을 때, 차이는 무엇일까?
```cpp
// 1
struct st{
  int a;
  char b;
} x,y,z;

// 2
struct {
  int a;
  char b;
} k,l,m;
```

- 1번 케이스는 **struct st** 라는 타입을 가지고 추가로 변수 생성이 가능하다.
- 2번 케이스는 타입을 알수가 없다. **tag** 가 없으므로 재활용이 불가하다.
이런 케이스는 k,l,m이라는 변수만 쓰겠다는 의도이다.

### 구조체와 멤버의 타입 추론, 초기화 시점과 멤버 값 업데이트
```cpp
struct st {
  int a;
  char b;
};

struct st x = {100, 'A'}; // 가능
struct st y;
y = {100, 'A'}; // 불가능
```
- x의 타입은 ```struct st```타입이다.
- x.a의 타입(x의 멤버 a)은 멤버의 타입인 **int** 형이다.
- 구조체 선언시에 값을 할당하는 것은 가능하다. 그러나, 구조체 선언 후, 구조체 변수에 초기화 시키는 것을 가능하다.


------------------------------------
## Enumeration
- 말그대로 "열거"하는 타입이다.
- enum 타입을 통해서 magic number들을 없앨 수 있다.
- 코드의 가독성을 높일 수 있다.
- 각 요소별로 값을 지정하는 것 또한 가능하다.
- enum 은 변수를 만들기 위한 타입이라기 보다는, **정수 상수 값** 을 만들기 위해서 사용한다.
- **체크해 볼 것** enum 타입은 컴파일 시점에 값이 정해지는가?

```cpp
// 차례대로 0 1 2 3 값이 들어간다.
enum color { white, black, yellow, red };

// 차례대로 2 3 -2 -1 2 값이 들어간다.
enum fruit{apple=2, banana, watermelon=-2, grape, pineapple=2};

```
